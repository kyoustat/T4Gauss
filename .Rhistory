}
## apply clustering with different k values
cl2 <- gauss.kmedoids(mylist, k=2)$cluster
cl3 <- gauss.kmedoids(mylist, k=3)$cluster
cl4 <- gauss.kmedoids(mylist, k=4)$cluster
## compute 2-dimensional embedding for visualization
mds2d <- gauss.mds(mylist, ndim=2)$embed
mdsx <- as.vector(mds2d[,1])
mdsy <- as.vector(mds2d[,2])
## visualize
opar = par(mfrow=c(1,3), pty="s")
plot(mdsx, mdsy, pch=19, col=cl2, main="k=2 medoids")
plot(mdsx, mdsy, pch=19, col=cl3, main="k=3 medoids")
plot(mdsx, mdsy, pch=19, col=cl4, main="k=4 medoids")
par(opar)
## generate three-cluster data with univariate Gaussians
mylist = list()
for (i in 1:10){
mylist[[i]] = wrapgauss1d(mean=-2-runif(1), sd=runif(1))
}
for (i in 11:20){
mylist[[i]] = wrapgauss1d(mean=0, sd=runif(1))
}
for (i in 21:30){
mylist[[i]] = wrapgauss1d(mean=2+runif(1), sd=runif(1))
}
## apply clustering with different k values
cl2 <- gauss.kmedoids(mylist, k=2)$cluster
cl3 <- gauss.kmedoids(mylist, k=3)$cluster
cl4 <- gauss.kmedoids(mylist, k=4)$cluster
## compute 2-dimensional embedding for visualization
mds2d <- gauss.mds(mylist, ndim=2)$embed
mdsx <- as.vector(mds2d[,1])
mdsy <- as.vector(mds2d[,2])
## visualize
opar = par(mfrow=c(1,3), pty="s")
plot(mdsx, mdsy, pch=19, col=cl2, main="k=2 medoids")
plot(mdsx, mdsy, pch=19, col=cl3, main="k=3 medoids")
plot(mdsx, mdsy, pch=19, col=cl4, main="k=4 medoids")
par(opar)
## generate three-cluster data with univariate Gaussians
mylist = list()
for (i in 1:10){
mylist[[i]] = wrapgauss1d(mean=-2-runif(1), sd=runif(1))
}
for (i in 11:20){
mylist[[i]] = wrapgauss1d(mean=0, sd=runif(1))
}
for (i in 21:30){
mylist[[i]] = wrapgauss1d(mean=2+runif(1), sd=runif(1))
}
## apply clustering with different k values
cl2 <- gauss.kmedoids(mylist, k=2)$cluster
cl3 <- gauss.kmedoids(mylist, k=3)$cluster
cl4 <- gauss.kmedoids(mylist, k=4)$cluster
## compute 2-dimensional embedding for visualization
mds2d <- gauss.mds(mylist, ndim=2)$embed
mdsx <- as.vector(mds2d[,1])
mdsy <- as.vector(mds2d[,2])
## visualize
opar = par(mfrow=c(1,3), pty="s")
plot(mdsx, mdsy, pch=19, col=cl2, main="k=2 medoids")
plot(mdsx, mdsy, pch=19, col=cl3, main="k=3 medoids")
plot(mdsx, mdsy, pch=19, col=cl4, main="k=4 medoids")
par(opar)
## generate three-cluster data with univariate Gaussians
mylist = list()
for (i in 1:10){
mylist[[i]] = wrapgauss1d(mean=-2-runif(1), sd=runif(1))
}
for (i in 11:20){
mylist[[i]] = wrapgauss1d(mean=0, sd=runif(1))
}
for (i in 21:30){
mylist[[i]] = wrapgauss1d(mean=2+runif(1), sd=runif(1))
}
## apply clustering with different k values
cl2 <- gauss.kmedoids(mylist, k=2)$cluster
cl3 <- gauss.kmedoids(mylist, k=3)$cluster
cl4 <- gauss.kmedoids(mylist, k=4)$cluster
## compute 2-dimensional embedding for visualization
mds2d <- gauss.mds(mylist, ndim=2)$embed
mdsx <- as.vector(mds2d[,1])
mdsy <- as.vector(mds2d[,2])
## visualize
opar = par(mfrow=c(1,3), pty="s")
plot(mdsx, mdsy, pch=19, col=cl2, main="k=2 medoids")
plot(mdsx, mdsy, pch=19, col=cl3, main="k=3 medoids")
plot(mdsx, mdsy, pch=19, col=cl4, main="k=4 medoids")
par(opar)
## generate three-cluster data with univariate Gaussians
mylist = list()
for (i in 1:10){
mylist[[i]] = wrapgauss1d(mean=-2-runif(1), sd=runif(1))
}
for (i in 11:20){
mylist[[i]] = wrapgauss1d(mean=0, sd=runif(1))
}
for (i in 21:30){
mylist[[i]] = wrapgauss1d(mean=2+runif(1), sd=runif(1))
}
## apply clustering with different k values
cl2 <- gauss.kmedoids(mylist, k=2)$cluster
cl3 <- gauss.kmedoids(mylist, k=3)$cluster
cl4 <- gauss.kmedoids(mylist, k=4)$cluster
## compute 2-dimensional embedding for visualization
mds2d <- gauss.mds(mylist, ndim=2)$embed
mdsx <- as.vector(mds2d[,1])
mdsy <- as.vector(mds2d[,2])
## visualize
opar = par(mfrow=c(1,3), pty="s")
plot(mdsx, mdsy, pch=19, col=cl2, main="k=2 medoids")
plot(mdsx, mdsy, pch=19, col=cl3, main="k=3 medoids")
plot(mdsx, mdsy, pch=19, col=cl4, main="k=4 medoids")
par(opar)
## generate three-cluster data with univariate Gaussians
mylist = list()
for (i in 1:10){
mylist[[i]] = wrapgauss1d(mean=-2-runif(1), sd=runif(1))
}
for (i in 11:20){
mylist[[i]] = wrapgauss1d(mean=0, sd=runif(1))
}
for (i in 21:30){
mylist[[i]] = wrapgauss1d(mean=2+runif(1), sd=runif(1))
}
## apply clustering with different k values
cl2 <- gauss.kmedoids(mylist, k=2)$cluster
cl3 <- gauss.kmedoids(mylist, k=3)$cluster
cl4 <- gauss.kmedoids(mylist, k=4)$cluster
## compute 2-dimensional embedding for visualization
mds2d <- gauss.mds(mylist, ndim=2)$embed
mdsx <- as.vector(mds2d[,1])
mdsy <- as.vector(mds2d[,2])
## visualize
opar = par(mfrow=c(1,3), pty="s")
plot(mdsx, mdsy, pch=19, col=cl2, main="k=2 medoids")
plot(mdsx, mdsy, pch=19, col=cl3, main="k=3 medoids")
plot(mdsx, mdsy, pch=19, col=cl4, main="k=4 medoids")
par(opar)
## generate three-cluster data with univariate Gaussians
mylist = list()
for (i in 1:10){
mylist[[i]] = wrapgauss1d(mean=-2-runif(1), sd=runif(1))
}
for (i in 11:20){
mylist[[i]] = wrapgauss1d(mean=0, sd=runif(1))
}
for (i in 21:30){
mylist[[i]] = wrapgauss1d(mean=2+runif(1), sd=runif(1))
}
## apply clustering with different k values
cl2 <- gauss.kmeans(mylist, k=2)$cluster
cl3 <- gauss.kmeans(mylist, k=3)$cluster
cl4 <- gauss.kmeans(mylist, k=4)$cluster
## compute 2-dimensional embedding for visualization
mds2d <- gauss.mds(mylist, ndim=2)$embed
mdsx <- as.vector(mds2d[,1])
mdsy <- as.vector(mds2d[,2])
## visualize
opar = par(mfrow=c(1,3), pty="s")
plot(mdsx, mdsy, pch=19, col=cl2, main="k=2 means")
plot(mdsx, mdsy, pch=19, col=cl3, main="k=3 means")
plot(mdsx, mdsy, pch=19, col=cl4, main="k=4 means")
par(opar)
## generate three-cluster data with univariate Gaussians
mylist = list()
for (i in 1:10){
mylist[[i]] = wrapgauss1d(mean=-2-runif(1), sd=runif(1))
}
for (i in 11:20){
mylist[[i]] = wrapgauss1d(mean=0, sd=runif(1))
}
for (i in 21:30){
mylist[[i]] = wrapgauss1d(mean=2+runif(1), sd=runif(1))
}
## apply clustering with different k values
cl2 <- gauss.kmeans(mylist, k=2)$cluster
cl3 <- gauss.kmeans(mylist, k=3)$cluster
cl4 <- gauss.kmeans(mylist, k=4)$cluster
## compute 2-dimensional embedding for visualization
mds2d <- gauss.mds(mylist, ndim=2)$embed
mdsx <- as.vector(mds2d[,1])
mdsy <- as.vector(mds2d[,2])
## visualize
opar = par(mfrow=c(1,3), pty="s")
plot(mdsx, mdsy, pch=19, col=cl2, main="k=2 means")
plot(mdsx, mdsy, pch=19, col=cl3, main="k=3 means")
plot(mdsx, mdsy, pch=19, col=cl4, main="k=4 means")
par(opar)
## generate three-cluster data with univariate Gaussians
mylist = list()
for (i in 1:10){
mylist[[i]] = wrapgauss1d(mean=-2-runif(1), sd=runif(1))
}
for (i in 11:20){
mylist[[i]] = wrapgauss1d(mean=0, sd=runif(1))
}
for (i in 21:30){
mylist[[i]] = wrapgauss1d(mean=2+runif(1), sd=runif(1))
}
## apply clustering with different k values
cl2 <- gauss.kmeans(mylist, k=2)$cluster
cl3 <- gauss.kmeans(mylist, k=3)$cluster
cl4 <- gauss.kmeans(mylist, k=4)$cluster
## compute 2-dimensional embedding for visualization
mds2d <- gauss.mds(mylist, ndim=2)$embed
mdsx <- as.vector(mds2d[,1])
mdsy <- as.vector(mds2d[,2])
## visualize
opar = par(mfrow=c(1,3), pty="s")
plot(mdsx, mdsy, pch=19, col=cl2, main="k=2 means")
plot(mdsx, mdsy, pch=19, col=cl3, main="k=3 means")
plot(mdsx, mdsy, pch=19, col=cl4, main="k=4 means")
par(opar)
## generate three-cluster data with univariate Gaussians
mylist = list()
for (i in 1:10){
mylist[[i]] = wrapgauss1d(mean=-2-runif(1), sd=runif(1))
}
for (i in 11:20){
mylist[[i]] = wrapgauss1d(mean=0, sd=runif(1))
}
for (i in 21:30){
mylist[[i]] = wrapgauss1d(mean=2+runif(1), sd=runif(1))
}
## apply clustering with different k values
cl2 <- gauss.kmeans(mylist, k=2)$cluster
cl3 <- gauss.kmeans(mylist, k=3)$cluster
cl4 <- gauss.kmeans(mylist, k=4)$cluster
## compute 2-dimensional embedding for visualization
mds2d <- gauss.mds(mylist, ndim=2)$embed
mdsx <- as.vector(mds2d[,1])
mdsy <- as.vector(mds2d[,2])
## visualize
opar = par(mfrow=c(1,3), pty="s")
plot(mdsx, mdsy, pch=19, col=cl2, main="k=2 means")
plot(mdsx, mdsy, pch=19, col=cl3, main="k=3 means")
plot(mdsx, mdsy, pch=19, col=cl4, main="k=4 means")
par(opar)
## generate three-cluster data with univariate Gaussians
mylist = list()
for (i in 1:10){
mylist[[i]] = wrapgauss1d(mean=-2-runif(1), sd=runif(1))
}
for (i in 11:20){
mylist[[i]] = wrapgauss1d(mean=0, sd=runif(1))
}
for (i in 21:30){
mylist[[i]] = wrapgauss1d(mean=2+runif(1), sd=runif(1))
}
## apply clustering with different k values
cl2 <- gauss.kmeans(mylist, k=2)$cluster
cl3 <- gauss.kmeans(mylist, k=3)$cluster
cl4 <- gauss.kmeans(mylist, k=4)$cluster
## compute 2-dimensional embedding for visualization
mds2d <- gauss.mds(mylist, ndim=2)$embed
mdsx <- as.vector(mds2d[,1])
mdsy <- as.vector(mds2d[,2])
## visualize
opar = par(mfrow=c(1,3), pty="s")
plot(mdsx, mdsy, pch=19, col=cl2, main="k=2 means")
plot(mdsx, mdsy, pch=19, col=cl3, main="k=3 means")
plot(mdsx, mdsy, pch=19, col=cl4, main="k=4 means")
par(opar)
library(T4Gauss)
x1 = rmvnorm(50, mean=rep(-1,4))
x2 = rmvnorm(50, mean=rep(+1,4))
xx = rbind(x1, x2)
cl1 = fitgmm(xx, k=1)
cl1
gmmlist = list()
x1 = rmvnorm(50, mean=rep(-1,4))
x2 = rmvnorm(50, mean=rep(+1,4))
xx = rbind(x1, x2)
cl1 = fitgmm(xx, k=1)
cl2 = fitgmm(xx, k=2)
cl3 = fitgmm(xx, k=3)
gmmlist = list()
gmmlist[[1]] = cl1
gmmlist[[2]] = cl2
gmmlist[[3]] = cl3
extract_dimension <- function(gmmobj){
return(round(gmmobj$wglist[[1]]$dimension))
}
cond1 = is.list(gmmlist)
cond2 = (all(unlist(lapply(gmmlist, inherits, "wrapgmm"))==TRUE))
cond3 = (length(unique(unlist(lapply(gmmlist, extract_dimension))))==1)
extract_dimension <- function(gmmobj){
return(round(gmmobj$wglist[[1]]$dimension))
}
extract_dimension(gmmlist[[1]])
gmmobj = gmmlist[[1]]
gmmobj
gmmobj$gmmobj
extract_dimension <- function(myobj){
return(round(myobj$gmmobj$wglist[[1]]$dimension))
}
cond1 = is.list(gmmlist)
cond2 = (all(unlist(lapply(gmmlist, inherits, "wrapgmm"))==TRUE))
cond3 = (length(unique(unlist(lapply(gmmlist, extract_dimension))))==1)
cond3
gmmlist
names(gmmlist)
gmmlist
x1 = rmvnorm(50, mean=rep(-1,4))
x2 = rmvnorm(50, mean=rep(+1,4))
xx = rbind(x1, x2)
cl1 = fitgmm(xx, k=1)
cl2 = fitgmm(xx, k=2)
cl3 = fitgmm(xx, k=3)
gmmlist = list()
gmmlist[[1]] = cl1
gmmlist[[2]] = cl2
gmmlist[[3]] = cl3
cond2 = (all(unlist(lapply(gmmlist, inherits, "wrapgmm"))==TRUE))
cond2
class(gmmlist[[1]])
gmmlist[[1]]
class(cl1)
cl1
rm(list=ls())
x1 = rmvnorm(50, mean=rep(-1,4))
x2 = rmvnorm(50, mean=rep(+1,4))
xx = rbind(x1, x2)
cl1 = fitgmm(xx, k=1)
cl2 = fitgmm(xx, k=2)
cl3 = fitgmm(xx, k=3)
gmmlist = list()
gmmlist[[1]] = cl1
gmmlist[[2]] = cl2
gmmlist[[3]] = cl3
class(cl1)
x1 = rmvnorm(50, mean=rep(-1,4))
x2 = rmvnorm(50, mean=rep(+1,4))
xx = rbind(x1, x2)
cl1 = fitgmm(xx, k=1)
cl2 = fitgmm(xx, k=2)
cl3 = fitgmm(xx, k=3)
gmmlist = list()
gmmlist[[1]] = cl1$gmmobj
gmmlist[[2]] = cl2$gmmobj
gmmlist[[3]] = cl3$gmmobj
extract_dimension <- function(myobj){
return(round(myobj$wglist[[1]]$dimension))
}
cond1 = is.list(gmmlist)
cond2 = (all(unlist(lapply(gmmlist, inherits, "wrapgmm"))==TRUE))
cond3 = (length(unique(unlist(lapply(gmmlist, extract_dimension))))==1)
cond1
cond2
cond3
mynlist = length(gmmlist)
myk     = 2
gmmlist[[1]]
gmmlist[[1]]$weight
n=1
tgtobj = gmmlist[[n]]
tgtobj$wglist
tgtobj$tgtobj
tgtobj$weight
array(0,c(5,2))
gmmlist
#######################################################
# Rearrange
#   weights : mynlist x sum(length(weights))
for (n in 1:mynlist){
tgtobj = gmmlist[[n]]
if (n < 2){
arr.props = matrix(tgtobj$weight, nrow=1)
arr.comps = tgtobj$weight
} else {
counter = length(tgtobj$weight)
arr.comps = c(arr.comps, tgtobj$wglist) # concatenate components
arr.props = rbind(cbind(arr.prop, array(0,c(nrow(arr.prop),counter))),c(rep(0,ncol(arr.prop)), as.vector(tgtobj$weight)))
}
}
#######################################################
# Rearrange
#   weights : mynlist x sum(length(weights))
for (n in 1:mynlist){
tgtobj = gmmlist[[n]]
if (n < 2){
arr.props = matrix(tgtobj$weight, nrow=1)
arr.comps = tgtobj$weight
} else {
counter = length(tgtobj$weight)
arr.comps = c(arr.comps, tgtobj$wglist) # concatenate components
arr.props = rbind(cbind(arr.prop, array(0,c(nrow(arr.props),counter))),c(rep(0,ncol(arr.props)), as.vector(tgtobj$weight)))
}
}
#######################################################
# Rearrange
#   weights : mynlist x sum(length(weights))
for (n in 1:mynlist){
tgtobj = gmmlist[[n]]
if (n < 2){
arr.props = matrix(tgtobj$weight, nrow=1)
arr.comps = tgtobj$weight
} else {
counter = length(tgtobj$weight)
arr.comps = c(arr.comps, tgtobj$wglist) # concatenate components
arr.props = rbind(cbind(arr.props, array(0,c(nrow(arr.props),counter))),c(rep(0,ncol(arr.props)), as.vector(tgtobj$weight)))
}
}
arr.props
arr.comps
clabel = gauss.kmeans(arr.comps, k=myk)$cluster
arr.comps
clabel = gauss.kmedoids(arr.comps, k=myk)
arr.props
arr.comps
mylist = list()
for (i in 1:10){
mylist[[i]] = wrapgauss1d(mean=-2-runif(1), sd=runif(1))
}
for (i in 11:20){
mylist[[i]] = wrapgauss1d(mean=0, sd=runif(1))
}
for (i in 21:30){
mylist[[i]] = wrapgauss1d(mean=2+runif(1), sd=runif(1))
}
mylist
arr.comps
mylist
gauss.kmedoids(arr.comps, k=2)
gauss.kmedoids(arr.comps, k=3)
class(arr.comps)
class(mylist)
class(mylist[[1]])
class(arr.comps[[1]])
arr.comps
x1 = rmvnorm(50, mean=rep(-1,4))
x2 = rmvnorm(50, mean=rep(+1,4))
xx = rbind(x1, x2)
cl1 = fitgmm(xx, k=1)
cl2 = fitgmm(xx, k=2)
cl3 = fitgmm(xx, k=3)
gmmlist = list()
gmmlist[[1]] = cl1$gmmobj
gmmlist[[2]] = cl2$gmmobj
gmmlist[[3]] = cl3$gmmobj
#######################################################
# Rearrange
#   arr.props (weights)    : mynlist x sum(length(weights))
#   arr.comps (components) : list of 'wrapgauss' length sum(length(weights))
for (n in 1:mynlist){
tgtobj = gmmlist[[n]]
if (n < 2){
arr.props = matrix(tgtobj$weight, nrow=1)
arr.comps = tgtobj$weight
} else {
counter = length(tgtobj$weight)
arr.comps = c(arr.comps, tgtobj$wglist) # concatenate components
arr.props = rbind(cbind(arr.props, array(0,c(nrow(arr.props),counter))),c(rep(0,ncol(arr.props)), as.vector(tgtobj$weight)))
}
}
arr.comps
#######################################################
# Rearrange
#   arr.props (weights)    : mynlist x sum(length(weights))
#   arr.comps (components) : list of 'wrapgauss' length sum(length(weights))
for (n in 1:mynlist){
tgtobj = gmmlist[[n]]
if (n < 2){
arr.props = matrix(tgtobj$weight, nrow=1)
arr.comps = tgtobj$wglist
} else {
counter = length(tgtobj$weight)
arr.comps = c(arr.comps, tgtobj$wglist) # concatenate components
arr.props = rbind(cbind(arr.props, array(0,c(nrow(arr.props),counter))),c(rep(0,ncol(arr.props)), as.vector(tgtobj$weight)))
}
}
clabel = gauss.kmedoids(arr.comps, k=myk)
clabel
clabel = gauss.kmedoids(arr.comps, k=myk)$clustering
clabel
clist = gauss.kmeans.center(arr.comps, clabel, myk, "wass2") # use 'wass2' center
arr.props
mynlist
#######################################################
# Step 2. Merge Component Weights
ulabel  = unique(clabel)
cprops  = array(0,c(mynlist, length(ulabel)))
for (i in 1:length(ulabel)){
idnow = which(clabel==ulabel[i])
if (length(idnow)==1){
cprops[,i] = arr.props[,idnow]
} else {
cprops[,i] = base::rowSums(arr.props[,idnow])
}
}
cprops
library(RiemSphere)
help("mle.spnorm")
#######################################################
# Step 3. Use RiemSphere
mle.spnorm(sqrt(cprops), method="Optimize")
#################################################################
# Step 3. Use RiemSphere to compute mean element of Simplex
as.vector(mle.spnorm(sqrt(cprops), method="Optimize")$mu)
#################################################################
# Step 3. Use RiemSphere to compute mean element of Simplex
(as.vector(mle.spnorm(sqrt(cprops), method="Optimize")$mu)^2)
#################################################################
# Step 3. Use RiemSphere to compute mean element of Simplex
sum(as.vector(mle.spnorm(sqrt(cprops), method="Optimize")$mu)^2)
#################################################################
# Step 3. Use RiemSphere to compute mean element of Simplex
cweight = (as.vector(mle.spnorm(sqrt(cprops), method="Optimize")$mu)^2)
cweight
library(T4Gauss)
